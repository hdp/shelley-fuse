#!/usr/bin/env bash
#
# approve [ticket-id]
#
# Idempotent cleanup: close ticket, rebase onto main, squash into single commit,
# ff-merge, remove worktree and branch. Safe to run repeatedly — skips
# already-completed steps.
#
# Guards against self-approval: refuses to proceed if HEAD has moved since
# `just review` was launched or if there are uncommitted changes in the
# worktree. This ensures a fresh review agent has seen the final state.
#
# Can be run from the main worktree or from a ticket's worktree. When run from
# a worktree, the ticket is inferred from the directory/branch name and the
# script re-executes itself from the main worktree.
#
# Exit codes:
#   0  — all done
#   1  — failed at a step that needs manual/agent intervention (e.g. rebase conflict)
#
set -euo pipefail

# ---------------------------------------------------------------------------
# Resolve main worktree and detect if we're in a non-main worktree
# ---------------------------------------------------------------------------
main_wt=$(git worktree list --porcelain | awk '/^worktree /{print $2; exit}')
current_wt=$(git rev-parse --show-toplevel)

if [ "$current_wt" != "$main_wt" ]; then
    # We're in a worktree — infer ticket from arg, branch name, or directory name
    if [ -n "${1:-}" ]; then
        ticket="$1"
    else
        ticket=$(git rev-parse --abbrev-ref HEAD 2>/dev/null) || true
        if [ -z "$ticket" ] || [ "$ticket" = "HEAD" ]; then
            ticket=$(basename "$current_wt")
        fi
    fi
    echo "Running from worktree — delegating to main worktree ($main_wt)"
    cd "$main_wt"
    # Always run main's copy of the script (worktree may have stale version)
    exec "$main_wt/scripts/approve" "$ticket"
fi

# ---------------------------------------------------------------------------
# We're in the main worktree from here on
# ---------------------------------------------------------------------------
if [ -n "${1:-}" ]; then
    ticket="$1"
else
    echo "ERROR: ticket ID required when running from main worktree" >&2
    echo "Usage: approve <ticket-id>" >&2
    exit 1
fi

# ---------------------------------------------------------------------------
# Resolve worktree directory for this ticket
# ---------------------------------------------------------------------------
worktree_dir=$(git worktree list --porcelain | awk -v t="$ticket" '/^worktree /{ wt=$2 } /^branch /{ if ($2 ~ t) print wt }')
# Also check for detached worktrees by path convention
if [ -z "$worktree_dir" ]; then
    candidate="/home/exedev/worktree/shelley-fuse/$ticket"
    if git worktree list | grep -q "$candidate"; then
        worktree_dir="$candidate"
    fi
fi

branch_exists() { git rev-parse --verify "refs/heads/$ticket" &>/dev/null; }
worktree_exists() { [ -n "$worktree_dir" ] && git worktree list | grep -q "$worktree_dir"; }

step() { printf '\n--- %s ---\n' "$*"; }

# ---------------------------------------------------------------------------
# Guard: reject self-approval
# ---------------------------------------------------------------------------
if worktree_exists; then
    review_head_file="$worktree_dir/.review-head"
    if [ -f "$review_head_file" ]; then
        review_head=$(cat "$review_head_file")
        current_head=$(git -C "$worktree_dir" rev-parse HEAD 2>/dev/null) || true

        if [ "$review_head" != "$current_head" ]; then
            echo "ERROR: HEAD has moved since the review started." >&2
            echo "The reviewer made changes that haven't been independently reviewed." >&2
            echo "Run 'just review $ticket' to get fresh eyes on the changes." >&2
            exit 1
        fi
    fi

    dirty=$(git -C "$worktree_dir" status --porcelain 2>/dev/null) || true
    if [ -n "$dirty" ]; then
        echo "ERROR: Worktree has uncommitted changes." >&2
        echo "The reviewer made changes that haven't been committed or reviewed." >&2
        echo "Run 'just review $ticket' to get fresh eyes on the changes." >&2
        exit 1
    fi
fi

# ---------------------------------------------------------------------------
# 1. Abort any in-progress rebase in the worktree
# ---------------------------------------------------------------------------
if worktree_exists; then
    if [ -d "$worktree_dir/.git" ] || [ -f "$worktree_dir/.git" ]; then
        git -C "$worktree_dir" rebase --abort 2>/dev/null || true
    fi
fi

# ---------------------------------------------------------------------------
# 2. Close the ticket (idempotent — skips if already closed or not found)
# ---------------------------------------------------------------------------
status=$(tk show "$ticket" 2>/dev/null | awk '/^status:/{print $2}') || true
if [ -n "$status" ] && [ "$status" != "closed" ]; then
    step "Closing ticket $ticket"
    # Commit the status change wherever the file lives
    ticket_file=".tickets/${ticket}.md"
    if worktree_exists; then
        (cd "$worktree_dir" && tk close "$ticket")
        git -C "$worktree_dir" commit --amend --no-edit -- "$ticket_file" 2>/dev/null || true
    elif [ -f "$ticket_file" ]; then
        if branch_exists; then
            git checkout $ticket
            tk close "$ticket"
            git commit --amend --no-edit -- "$ticket_file" 2>/dev/null
        else
            tk close "$ticket"
            git commit -m "Close $ticket" -- "$ticket_file" 2>/dev/null
        fi
    fi
fi

# ---------------------------------------------------------------------------
# 3. Rebase, squash & merge (only if branch exists with commits ahead of main)
# ---------------------------------------------------------------------------
if branch_exists; then
    ahead=$(git rev-list --count "main..$ticket" 2>/dev/null || echo 0)
    if [ "$ahead" -gt 0 ]; then
        step "Rebasing $ticket onto main ($ahead commit(s) ahead)"
        if worktree_exists; then
            git -C "$worktree_dir" rebase main
        else
            # No worktree — rebase the branch directly
            git rebase main "$ticket"
        fi

        # Build squash commit message: ticket title as subject, reviewer
        # summary as body (falls back to concatenated commit messages)
        ticket_title=$(sed -n '/^# /{s/^# //p;q}' ".tickets/${ticket}.md" 2>/dev/null) || true
        commit_msg_file=""
        if worktree_exists && [ -f "$worktree_dir/.commit-message" ]; then
            commit_msg_file="$worktree_dir/.commit-message"
        elif [ -f ".commit-message" ]; then
            commit_msg_file=".commit-message"
        fi

        if [ -n "$commit_msg_file" ]; then
            # Reviewer wrote a summary — use ticket title as subject + summary as body
            squash_msg="${ticket}: ${ticket_title:-Completed ticket work}

$(cat "$commit_msg_file")"
        else
            # No reviewer summary — fall back to commit log
            commit_body=$(git log main..$ticket --reverse --format="- %s" 2>/dev/null) || true
            squash_msg="${ticket}: ${ticket_title:-Completed ticket work}${commit_body:+

${commit_body}}"
        fi

        step "Squashing $ticket into a single commit"
        if worktree_exists; then
            git -C "$worktree_dir" reset --soft main
            git -C "$worktree_dir" commit -m "$squash_msg"
        else
            # Already on the ticket branch after rebase
            git reset --soft main
            git commit -m "$squash_msg"
            git checkout main
        fi

        step "Fast-forward merging $ticket into main"
        stashed=false
        if ! git diff --quiet 2>/dev/null || ! git diff --cached --quiet 2>/dev/null; then
            git stash push -m "approve: temp stash for $ticket merge"
            stashed=true
        fi
        git merge --ff-only "$ticket"
        if [ "$stashed" = true ]; then
            git stash pop
        fi
    else
        step "Branch $ticket has no commits ahead of main — skipping merge"
    fi
fi

# ---------------------------------------------------------------------------
# 4. Remove worktree
# ---------------------------------------------------------------------------
if worktree_exists; then
    step "Removing worktree $worktree_dir"
    git worktree remove --force "$worktree_dir"
fi
git worktree prune 2>/dev/null || true

# ---------------------------------------------------------------------------
# 5. Delete branch
# ---------------------------------------------------------------------------
if branch_exists; then
    step "Deleting branch $ticket"
    git branch -D "$ticket"
fi

# ---------------------------------------------------------------------------
# 6. Archive conversation
# ---------------------------------------------------------------------------
if ls /shelley/conversation/*/ctl >/dev/null 2>&1; then
    fgrep -l "$worktree_dir" /shelley/conversation/*/ctl | \
        head -1 | xargs dirname | while read conv; do
            touch "$conv/archived"
    done
fi

# ---------------------------------------------------------------------------
# Done
# ---------------------------------------------------------------------------
echo ""
echo "✓ $ticket approved and merged."
